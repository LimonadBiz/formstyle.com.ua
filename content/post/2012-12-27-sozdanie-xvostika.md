---
title: Создание хвостика
author: admin
type: post
date: 2012-12-27T16:11:42+00:00
url: /sozdanie-xvostika/
categories:
  - Css 3

---
Теперь вы знаете, как сделать треугольник без помощи изображений. Давайте добавим треугольник слева от поля комментария так, чтобы он указывал на аватар пользователя. Для этого можно было бы вложить блок span или div внутрь каждого комментария, а затем трансформировать этот элемент в наш треугольник. Однако я предлагаю не менять код HTML и использовать для создания нужного нам элемента содержимое, генерируемое CSS.

Генерируемое содержимое (generated content) — это метод CSS 2.1, позволяющий делать так, чтобы содержимое из CSS появлялось в коде HTML. Его удобно применять для добавления элементов, которые вам не хочется программировать вручную в коде HTML, таких как порядковые номера в заголовках или значки после ссылок. Однако его не следует применять для важного содержимого, отсутствие которого исказит страницу или испортит впечатление пользователя, браузер которого не может загрузить файл CSS.

Для создания генерируемого содержимого необходимо указать, куда оно должно быть вставлено; для этого используются псевдоэлементы :: before и ::after (которые также можно записывать как :before и :after). Свойство content указывает на то, какое содержимое вставляется в код HTML.

откуда взялось двойное двоеточие?

Вы наверняка обратили внимание, что в названии псевдоэлементов ::before и ::after я использовала не привычное одинарное, а двойное двоеточие. Нет, это не опечатка. В CSS3 синтаксис псевдоэлементов поменялся, и теперь они записываются с двойным двоеточием, в то время как одинарное двоеточие сохраняется за псевдоклассами.

При желании вы можете продолжать использовать версию с одинарным двоеточием; она прекрасно работает. В действительности, поскольку IE 8 и более ранние версии не поддерживают запись с двойным двоеточием, в этой книге мы также будем придерживаться варианта с одинарным двоеточием. Кроме того, оба псевдоэлемента можно применять как групповые селекторы, например .caption:before, .caption::before { content: «Figure: »;}.

Например, для того чтобы вставить слово «Figure» перед подписями ко всем картинкам на странице, можно добавить такой код CSS:

.caption:before {

content: &#171;Figure: &#171;;

<sup>}</sup>

Благодаря такому коду фрагмент HTML <p class=«caption»>Isn&#8217;t my cat cute?</p>

на самой странице в браузере будет отображаться так:

Figure: Isn&#8217;t my cat cute?

Поскольку перед нами стоит задача сгенерировать хвостики к облачкам с текстом, в нашем случае отображаться должны только рамки сгенерированного содержимого, а не само содержимое. Чтобы добиться этого, давайте сгенерируем невидимое содержимое — неразрывный пробел.

В HTML неразрывный пробел обозначается мнемоникой &nbsp;, однако внутри свойства content невозможно применять мнемоники HTML. Вместо этого придется использовать шестнадцатеричную часть элемента кода Unicode для данного символа. Многим из вас может показаться, что эта китайская грамота доступна лишь самым продвинутым разработчикам, но не пугайтесь — в Сети можно найти массу удобных таблиц, содержащих подобные значения.

Например, на сайте <http://www.digitalmediaminute.com/reference/entity/> вы видите 252 маленьких поля, в каждом из которых отображается одна допустимая мнемоника (X)HTML. В поле Filter entities by keyword

<div>
  <p>
    Еще один полезный инструмент — конвертер Unicode Code Converter, адрес которого <a href="http://rishida.net/">http://rishida.net/</a> tools/conversion. Здесь вы вводите символ или его мнемонику HTML в текстовое поле и можете преобразовать ее в разнообразные форматы, в том числе получить шестнадцатеричный элемент кода.
  </p>
</div>

&nbsp;

(Фильтровать записи по ключевому слову) введите «non-breaking space». 251 поле пропадет, и на странице останется только одно поле, содержащее имя мнемоники в HTML, &nbsp;. Подведите указатель мыши к этому полю (рис. 2.8). Появятся еще два кода: числовой код мнемоники (в данном случае &#160;) и ее код Unicode (u00A0). Вас интересует шестнадцатеричная часть кода Unicode, т. е. то, что находится после «u». Скопируйте текст 00A0 в буфер обмена.

Почти все готово. Но, хотя мы и получили код Unicode, его невозможно напрямую добавить в свойство content, например, так:

blockquote:after { content:&#187;00A0&#8243;;

<sup>}</sup>

<div>
  <p>
    Элементы кода Unicode часто записываются с префиксом «U+» вместо простого «u». В любом случае, в свойстве content вы указываете только шестнадцатеричную часть, включающую четыре цифры и следующую за префиксом.
  </p>
</div>

&nbsp;

Если бы мы так сделали, то браузер вполне логично посчитал бы, что мы просим его отобразить текст «00A0», а не неразрывный пробел. Для того чтобы сообщить браузеру, что это не текст, а код специального символа, необходимо добавить управляющий символ. Программистам должна быть знакома эта концепция: вы добавляете перед кодом обратную косую черту, указывая,что далее следует особый набор символов. Таким образом, браузер воспринимает его не буквально, а как код, описывающий какой-то другой элемент.

<a href="http://formstyle.com.ua/?attachment_id=1271" rel="attachment wp-att-1271"><img class="aligncenter size-full wp-image-1271" alt="Таким образом, браузер воспринимает его не буквально, а как код, описывающий какой-то другой элемен" src="http://formstyle.com.ua/wp-content/uploads/2012/12/Таким-образом-браузер-воспринимает-его-не-буквально-а-как-код-описывающий-какой-то-другой-элемен.png" width="701" height="406" srcset="http://formstyle.com.ua/wp-content/uploads/2012/12/Таким-образом-браузер-воспринимает-его-не-буквально-а-как-код-описывающий-какой-то-другой-элемен.png 701w, http://formstyle.com.ua/wp-content/uploads/2012/12/Таким-образом-браузер-воспринимает-его-не-буквально-а-как-код-описывающий-какой-то-другой-элемен-300x173.png 300w" sizes="(max-width: 701px) 100vw, 701px" /></a>

Обращайтесь к странице XHTML Character Entity Reference для поиска соответствующих различным мнемоникам элементов кода Unicode

Благодаря обратной косой черте мы наконец-то получаем правильные символы и пунктуацию, необходимые для вставки простого неразрывного пробела:

blockquote:after { content:&#187;0A0&#8243;;

}

Но после добавления этого кода страница не изменится, ведь неразрывный пробел — это невидимый символ. Нужно добавить вокруг него рамки, и тогда мы сможем что-то увидеть на странице. Кроме того, мы должны установить для свойств width и height значение 0 и сделать так, чтобы пробел вместе с рамкой отображался как блочный элемент, что позволит нам переместить его и прикрепить сбоку от облачка с текстом:

blockquote:after { content: &#171;0A0&#187;; display: block; width: 0; height: 0;

border-width: 10px 20px 10px 0;

В данном случае мы могли бы с таким же успехом использовать псевдоэлемент :before, а не rafter. В любом случае, как вы скоро увидите, мы поменяем местоположение стрелочки по умолчанию.

border-style: solid;

border-color: transparent #000 transparent transparent;

<sup>}</sup>

Если бы все четыре отрезка рамки были одинаковой ширины, то у нас получился бы довольно толстый треугольник, как на рис. 2.7. Чтобы сделать его длиннее и уже, мы установили для верхнего и нижнего отрезков ширину 10 пикселов, а левый отрезок рамки сделали невидимым, т. е. нулевой ширины. Правый отрезок рамки — тот, что в результате превратился в указывающий влево треугольник — крупнее всех, его ширина составляет 20 пикселов. Все отрезки рамки, за исключением правого, прозрачные; для правого отрезка я временно выбрала черный цвет — так удобнее будет корректировать его местоположение (рис. 2.9).

Сейчас треугольник выводится сразу после содержимого blockquote — но хвостик облачка с текстом должен находиться совсем не там. Исправить местоположение можно, прибегнув к абсолютному позиционированию. Во-первых, добавьте к правилу blockquote еще одну строку, position: relative;. Таким образом, вы определите ориентир для абсолютного позиционирования элемента:

blockquote {

position: relative;

margin: 0 0 0 112px; padding: 10px 15px 5px 15px;

-moz-border-radius: 20px;

-webkit-border-radius: 20px; border-radius: 20px; border-top: 1px solid #fff; background-color: #A6DADC; word-wrap: break-word;

<sup>}</sup>

Теперь добавьте данные абсолютного позиционирования для генерируемого содержимого, а также укажите значения top и left:

blockquote:after { content: &#171;0a0&#187;; display: block; position: absolute; top: 20px; left: -20px; width: 0; height: 0;

border-width: 10px 20px 10px 0; border-style: solid;

border-color: transparent #000 transparent transparent;

<sup>}</sup>

Значение top может быть любым; удостоверьтесь только, что оно не меньше значения border-radius — это нужно, чтобы треугольник прикреплялся к прямой части окантовки поля, прямо под скругленным углом. Значение left должно быть отрицательным, чтобы треугольник выдавался влево, и совпадать с шириной треугольника. Ширина нашего треугольника — 20 пикселов (вспомните, это ширина правого отрезка рамки), поэтому значение left равно -20px. Таким образом, треугольник отображается слева от поля комментария вплотную к нему (рис. 2.10).

<a href="http://formstyle.com.ua/?attachment_id=1281" rel="attachment wp-att-1281"><img class="aligncenter size-full wp-image-1281" alt="Таким образом, треугольник отображается слева от поля комментария вплотную к нему" src="http://formstyle.com.ua/wp-content/uploads/2012/12/Таким-образом-треугольник-отображается-слева-от-поля-комментария-вплотную-к-нему.png" width="225" height="225" srcset="http://formstyle.com.ua/wp-content/uploads/2012/12/Таким-образом-треугольник-отображается-слева-от-поля-комментария-вплотную-к-нему.png 225w, http://formstyle.com.ua/wp-content/uploads/2012/12/Таким-образом-треугольник-отображается-слева-от-поля-комментария-вплотную-к-нему-150x150.png 150w, http://formstyle.com.ua/wp-content/uploads/2012/12/Таким-образом-треугольник-отображается-слева-от-поля-комментария-вплотную-к-нему-90x90.png 90w" sizes="(max-width: 225px) 100vw, 225px" /></a>

Правый отрезок рамки — черного цвета. Он выглядит, как указывающий влево черный треугольник . Абсолютное позиционирование помогает поместить треугольник в точности туда, где мы хотим его видеть

Если комментарий короткий, то его поле получается достаточно узким, и тогда хвостик некрасиво свисает, как у второго комментария на рис. 2.10. Для того чтобы исправить этот косметический недостаток, добавьте к правилу blockquote строку min-height: 42px;. blockquote {

position: relative; min-height: 42px; margin: 0 0 0 112px; padding: 10px 15px 5px 15px;

-moz-border-radius: 20px;

-webkit-border-radius: 20px; border-radius: 20px; border-top: 1px solid #fff; background-color: #A6DADC; word-wrap: break-word;

<sup>}</sup>

Теперь, когда треугольник выводится рядом с содержимым blockquote, а не поверх него, можно поменять цвет хвостика, для того чтобы он составлял единое целое с облачком:

blockquote:after { content: &#171;0a0&#187;; display: block; position: absolute;

top: 20px; left: -20px; width: 0; height: 0;

border-1width: 10px 20px 10px 0; border-style: solid;

<div>
  <p>
    Страница со всеми изменениями, внесенными до сих пор, находится в папке с файлами примеров, которые вы загрузили для этой главы, и носит название speech-bubble_1.html.
  </p>
</div>

&nbsp;

border-color: transparent #A6DADC transparent transparent;

<sup>}</sup>

С помощью этого несложного кода мы создали бесшовное соединение между облачками с текстом комментариев и их хвостиками (рис. 2.11).

<a href="http://formstyle.com.ua/?attachment_id=1291" rel="attachment wp-att-1291"><img class="aligncenter size-full wp-image-1291" alt="С помощью этого несложного кода мы создали бесшовное соединение между облачками с текстом комментариев и их хвостиками" src="http://formstyle.com.ua/wp-content/uploads/2012/12/С-помощью-этого-несложного-кода-мы-создали-бесшовное-соединение-между-облачками-с-текстом-комментариев-и-их-хвостиками.png" width="746" height="433" srcset="http://formstyle.com.ua/wp-content/uploads/2012/12/С-помощью-этого-несложного-кода-мы-создали-бесшовное-соединение-между-облачками-с-текстом-комментариев-и-их-хвостиками.png 746w, http://formstyle.com.ua/wp-content/uploads/2012/12/С-помощью-этого-несложного-кода-мы-создали-бесшовное-соединение-между-облачками-с-текстом-комментариев-и-их-хвостиками-300x174.png 300w" sizes="(max-width: 746px) 100vw, 746px" /></a>

Рис. 2.11. Теперь все хвостики расположены и окрашены правильно Обходные пути для IE

В IE 8 и более поздних версиях хвостик будет отображаться правильно, однако IE 7 и более ранние версии не поддерживают генерируемое содержимое, поэтому не смогут отобразить хвостики облачков с текстом. Мне кажется, что в этом нет ничего страшного. Вряд ли пользователи этих браузеров, взглянув на простой прямоугольник с текстом, воскликнут: «Эй, погодите-ка минуточку! Почему я не вижу маленького треугольника, торчащего из поля комментария?»

Чтобы добавить хвостики в IE 7 и предыдущих версиях, нужно вручную внести в код HTML каждого комментария дополнительный элемент, например пустой блок span, и превратить его в треугольник.

Создание полупрозрачного фона с помощью RGBA и HSLA

С формой облачков ничего больше делать не нужно — мы создали скругленные углы и хвостики, и этого достаточно — но мне все же хотелось бы с помощью дополнительных графических деталей добавить картинке глубины и визуальной насыщенности.

Прекрасный способ добиться этого — сделать фон полупрозрачным (использовать прозрачность в альфа-канале). Когда основной фон страницы немного просвечивает сквозь подложку комментария, создается впечатление многослойности, будто полупрозрачный элемент парит над страницей. Мне кажется, это особенно хорошо смотрится в применении к облачкам с текстом — ведь облачка и должны быть легкими и воздушными.

До появления CSS3 создать эффект полупрозрачности можно было, выложив фон изображениями в формате PNG с прозрачным альфа-каналом. Однако использование фонового изображения означает дополнительное обращение к серверу с целью получить оттуда файл, что замедляет загрузку страницы. Производительность сни-жалается еще сильнее в IE 6, так как для понимания прозрачности в альфа-канале этому браузеру требуется дополнительный сценарий. Помимо этого, невозможно с использованием изображения оформить рамку элемента, т. е. хвостик облачка все равно остался бы непрозрачным. Полупрозрачное облачко с хвостиком, залитым сплошным цветом, смотрелось бы, по меньшей мере, странно.